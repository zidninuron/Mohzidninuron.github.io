{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SELAMAT DATANG DI HALAMAN TUGAS \u00b6 Nama : moh Zidni Nuron Nim : 180411100053 Fakultas : Teknik Prodi : Teknik Informatika matakuliah : Komputasi Numerik \u200b","title":"Beranda"},{"location":"#selamat-datang-di-halaman-tugas","text":"Nama : moh Zidni Nuron Nim : 180411100053 Fakultas : Teknik Prodi : Teknik Informatika matakuliah : Komputasi Numerik \u200b","title":"SELAMAT DATANG DI HALAMAN TUGAS"},{"location":"DeretMacLaurin/","text":"Deret MacLaurin \u00b6 Deret MacLaurin adalah deret yang jika x0=0, juga bisa disebut sebagai deret Taylor baku. Dan Deret MacLaurin Adalah Suatu fungsi fungsi f (x) Yang memiliki turunan , , , Dan seterusnya Yang kontinyu hearts selang DENGAN Maka untuk review disekitar Yaitu , DAPAT diekspansi kedalam deret Taylor. Berikut adalah rumus deret MacLaurin: Contoh : \u00b6 Uraikan sin(x) dan $$ e^x $$ dalam deret MacLaurin Jawab: Kita tentukan terlebih dahulu turunan dari sin(x) sebagai berikut: f(x) = sin x f'(x) = cos x f''(x) = -sin x f'''(x) = -cos x f''''(x) = sin x Deret MacLaurin sin(x) adalah : $$ sin x = sin 0 + \\frac{cos 0}{1!}x+\\frac{-sin0}{2!}x 2+\\frac{-cos0}{3!}x 3+\\frac{sin0}{4!}x^4...... $$ =0+x-0-\\frac{x^3}{3!}+0+.... =0+x-0-\\frac{x^3}{3!}+0+.... = x - \\frac{x^3}{3!}+.... = x - \\frac{x^3}{3!}+.... Atau dinyatakan dengan : $$ **Deret MacLaurin=e^x** $$ e^x=e^0+\\frac{(x-0)}{1!}e^0+\\frac{(x-0)^2}{2!}+\\frac{(x-0)^3}{3!}+.... **Deret MacLaurin=e^x** $$ e^x=e^0+\\frac{(x-0)}{1!}e^0+\\frac{(x-0)^2}{2!}+\\frac{(x-0)^3}{3!}+.... =1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+.... =1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+.... Soal e ^ 2x \u00b6 \u200b Dalam banyak masalah terapan, pilihan dasar yang mudah digunakan adalah bilangan irasional e = 2,718281828 ... \u200b Bilangan ini disebut dasar alami . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. Untuk bilangan $$ e ^ 2x $$ maka:e 2 xe2x maka: jadi, kesimpulannya adalah sebagai berikut: kompilasi nilai x diganti dengan 4 maka hasil adalah 296,99. Daftar Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e ^ 2x dengan nilai x = 4 hingga nilai menjadi kurang dari 0,001 dapat dibuat dengan daftar program sebagai berikut. import math #Diketahui x = 4 nilai = 1 #nilai awal a = 0 b = 1 perulangan = 1 while nilai > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += int ( math . pow ( 2 , i )) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += int ( math . pow ( 2 , j )) * x ** j / math . factorial ( j ) nilai = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , perulangan , \"= \" , nilai ) perulangan += 1 Hasil Run : iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 Terimakasih semoga bermanfaat. Mathjax.Hub.Config({ tex2jax: {inLineMath: [['$$','$$']]} });","title":"Tugas 1"},{"location":"DeretMacLaurin/#deret-maclaurin","text":"Deret MacLaurin adalah deret yang jika x0=0, juga bisa disebut sebagai deret Taylor baku. Dan Deret MacLaurin Adalah Suatu fungsi fungsi f (x) Yang memiliki turunan , , , Dan seterusnya Yang kontinyu hearts selang DENGAN Maka untuk review disekitar Yaitu , DAPAT diekspansi kedalam deret Taylor. Berikut adalah rumus deret MacLaurin:","title":"Deret MacLaurin"},{"location":"DeretMacLaurin/#contoh","text":"Uraikan sin(x) dan $$ e^x $$ dalam deret MacLaurin Jawab: Kita tentukan terlebih dahulu turunan dari sin(x) sebagai berikut: f(x) = sin x f'(x) = cos x f''(x) = -sin x f'''(x) = -cos x f''''(x) = sin x Deret MacLaurin sin(x) adalah : $$ sin x = sin 0 + \\frac{cos 0}{1!}x+\\frac{-sin0}{2!}x 2+\\frac{-cos0}{3!}x 3+\\frac{sin0}{4!}x^4...... $$ =0+x-0-\\frac{x^3}{3!}+0+.... =0+x-0-\\frac{x^3}{3!}+0+.... = x - \\frac{x^3}{3!}+.... = x - \\frac{x^3}{3!}+.... Atau dinyatakan dengan : $$ **Deret MacLaurin=e^x** $$ e^x=e^0+\\frac{(x-0)}{1!}e^0+\\frac{(x-0)^2}{2!}+\\frac{(x-0)^3}{3!}+.... **Deret MacLaurin=e^x** $$ e^x=e^0+\\frac{(x-0)}{1!}e^0+\\frac{(x-0)^2}{2!}+\\frac{(x-0)^3}{3!}+.... =1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+.... =1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+....","title":"Contoh :"},{"location":"DeretMacLaurin/#soal-e-2x","text":"\u200b Dalam banyak masalah terapan, pilihan dasar yang mudah digunakan adalah bilangan irasional e = 2,718281828 ... \u200b Bilangan ini disebut dasar alami . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. Untuk bilangan $$ e ^ 2x $$ maka:e 2 xe2x maka: jadi, kesimpulannya adalah sebagai berikut: kompilasi nilai x diganti dengan 4 maka hasil adalah 296,99.","title":"Soal e ^ 2x"},{"location":"DeretMacLaurin/#daftar-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e ^ 2x dengan nilai x = 4 hingga nilai menjadi kurang dari 0,001 dapat dibuat dengan daftar program sebagai berikut. import math #Diketahui x = 4 nilai = 1 #nilai awal a = 0 b = 1 perulangan = 1 while nilai > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += int ( math . pow ( 2 , i )) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += int ( math . pow ( 2 , j )) * x ** j / math . factorial ( j ) nilai = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , perulangan , \"= \" , nilai ) perulangan += 1 Hasil Run : iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 Terimakasih semoga bermanfaat. Mathjax.Hub.Config({ tex2jax: {inLineMath: [['$$','$$']]} });","title":"Daftar Program"},{"location":"METODE%20NEWTON%20RAPHSON/","text":"METODE NEWTON RAPHSON \u00b6 \u200b Metode Newton Raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Titik pendekatan ke n+1 dituliskan dengan : Algoritma \u00b6 1.Definisikan fungsi f(x) dan f1(x) 2.Tentukan toleransi error (e) dan iterasi maksimum(n) 3.Tentukan nilai pendekatan awal x0 4.Hitung f(x0) dan f1(x0) 5.Untuk iterasi 1=1 s/d n atau |f(xi) e>= Hitung f(xi) dan f1(xi) Akar perasmaan adalah nilai xi yang terakhir diperoleh. Permasalahan \u00b6 Permasalahan pada pemakaian metode Newton Raphson adalah : Metode ini tidak dapat digunakan ketika titik pendekatannya berada pada titik ekstrim atau titik puncak, karena pada titik ini nilai F^1 (x) = 0 sehingga nilai penyebut dari f(x)/f^1(x) sama dengan nol, secara grafis dapat dilihat sebagai berikut: Bila titik pendekatan berada pada titik puncak, maka titik selanjutnya akan berada di tak berhingga. Metode ini menjadi sulit atau lama mendapatkan penyelesaian ketika titik pendekatannya berada di antara dua titik stasioner. \u200b Bila titik pendekatan berada pada dua tiitik puncak akan dapat mengakibatkan hilangnya penyelesaian (divergensi). Hal ini disebabkan titik selanjutnya berada pada salah satu titik puncak atau arah pendekatannya berbeda. Untuk dapat menyelesaikan kedua permasalahan pada metode Newton Raphson ini, maka metode Newton Raphson perlu dimodifikasi dengan : Bila titik pendekatan berada pada titik puncak maka titik pendekatan tersebut harus di geser sedikit, dimana \u03b4adalah konstanta yang ditentukan dengan demikian dan metode Newton Raphson tetap dapat berjalan Untuk menghindari titik-titik pendekatan yang berada jauh, sebaiknya pemakaian metode Newton Raphson ini didahului oleh metode tabel, sehingga dapat di jamin konvergensi dari metode Newton Raphson. Contoh Program \u00b6 Program python untuk memperkirakan akar polinomial: #import math - untuk mengambil library matematika #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function #berfungsi untuk menemukan turunan dari polinomial def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"iterasi ke-\" , i , \"=\" , x ) return ( \"\" ) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 20 iterasi dan ambil titik awal sebagai 1 print ( iterate ( 1 , 20 )) Banyak Iterasinya = 20 iterasi ke- 0 = 2.999994000093219 iterasi ke- 1 = 2.199996832141079 iterasi ke- 2 = 1.7808294919560141 iterasi ke- 3 = 1.6363030634057565 iterasi ke- 4 = 1.618304588651506 iterasi ke- 5 = 1.6180340496697716 iterasi ke- 6 = 1.6180339887499484 iterasi ke- 7 = 1.6180339887498947 iterasi ke- 8 = 1.618033988749895 iterasi ke- 9 = 1.618033988749895 iterasi ke- 10 = 1.618033988749895 iterasi ke- 11 = 1.618033988749895 iterasi ke- 12 = 1.618033988749895 iterasi ke- 13 = 1.618033988749895 iterasi ke- 14 = 1.618033988749895 iterasi ke- 15 = 1.618033988749895 iterasi ke- 16 = 1.618033988749895 iterasi ke- 17 = 1.618033988749895 iterasi ke- 18 = 1.618033988749895 iterasi ke- 19 = 1.618033988749895 >>> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 2"},{"location":"METODE%20NEWTON%20RAPHSON/#metode-newton-raphson","text":"\u200b Metode Newton Raphson adalah metode pendekatan yang menggunakan satu titik awal dan mendekatinya dengan memperhatikan slope atau gradien pada titik tersebut. Titik pendekatan ke n+1 dituliskan dengan :","title":"METODE NEWTON RAPHSON"},{"location":"METODE%20NEWTON%20RAPHSON/#algoritma","text":"1.Definisikan fungsi f(x) dan f1(x) 2.Tentukan toleransi error (e) dan iterasi maksimum(n) 3.Tentukan nilai pendekatan awal x0 4.Hitung f(x0) dan f1(x0) 5.Untuk iterasi 1=1 s/d n atau |f(xi) e>= Hitung f(xi) dan f1(xi) Akar perasmaan adalah nilai xi yang terakhir diperoleh.","title":"Algoritma"},{"location":"METODE%20NEWTON%20RAPHSON/#permasalahan","text":"Permasalahan pada pemakaian metode Newton Raphson adalah : Metode ini tidak dapat digunakan ketika titik pendekatannya berada pada titik ekstrim atau titik puncak, karena pada titik ini nilai F^1 (x) = 0 sehingga nilai penyebut dari f(x)/f^1(x) sama dengan nol, secara grafis dapat dilihat sebagai berikut: Bila titik pendekatan berada pada titik puncak, maka titik selanjutnya akan berada di tak berhingga. Metode ini menjadi sulit atau lama mendapatkan penyelesaian ketika titik pendekatannya berada di antara dua titik stasioner. \u200b Bila titik pendekatan berada pada dua tiitik puncak akan dapat mengakibatkan hilangnya penyelesaian (divergensi). Hal ini disebabkan titik selanjutnya berada pada salah satu titik puncak atau arah pendekatannya berbeda. Untuk dapat menyelesaikan kedua permasalahan pada metode Newton Raphson ini, maka metode Newton Raphson perlu dimodifikasi dengan : Bila titik pendekatan berada pada titik puncak maka titik pendekatan tersebut harus di geser sedikit, dimana \u03b4adalah konstanta yang ditentukan dengan demikian dan metode Newton Raphson tetap dapat berjalan Untuk menghindari titik-titik pendekatan yang berada jauh, sebaiknya pemakaian metode Newton Raphson ini didahului oleh metode tabel, sehingga dapat di jamin konvergensi dari metode Newton Raphson.","title":"Permasalahan"},{"location":"METODE%20NEWTON%20RAPHSON/#contoh-program","text":"Program python untuk memperkirakan akar polinomial: #import math - untuk mengambil library matematika #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f ( x ): function = ( x ** 3 ) - ( 2 * x ) - 1 return function #berfungsi untuk menemukan turunan dari polinomial def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate ( p , n ): print ( \"Banyak Iterasinya =\" , n ) x = p for i in range ( n ): x = newton_raphson ( x ) print ( \"iterasi ke-\" , i , \"=\" , x ) return ( \"\" ) #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 20 iterasi dan ambil titik awal sebagai 1 print ( iterate ( 1 , 20 )) Banyak Iterasinya = 20 iterasi ke- 0 = 2.999994000093219 iterasi ke- 1 = 2.199996832141079 iterasi ke- 2 = 1.7808294919560141 iterasi ke- 3 = 1.6363030634057565 iterasi ke- 4 = 1.618304588651506 iterasi ke- 5 = 1.6180340496697716 iterasi ke- 6 = 1.6180339887499484 iterasi ke- 7 = 1.6180339887498947 iterasi ke- 8 = 1.618033988749895 iterasi ke- 9 = 1.618033988749895 iterasi ke- 10 = 1.618033988749895 iterasi ke- 11 = 1.618033988749895 iterasi ke- 12 = 1.618033988749895 iterasi ke- 13 = 1.618033988749895 iterasi ke- 14 = 1.618033988749895 iterasi ke- 15 = 1.618033988749895 iterasi ke- 16 = 1.618033988749895 iterasi ke- 17 = 1.618033988749895 iterasi ke- 18 = 1.618033988749895 iterasi ke- 19 = 1.618033988749895 >>> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Contoh Program"},{"location":"Metode%20Eliminasi%20Gauss/","text":"**Metode Eliminasi Gauss Jordan* * \u00b6 \u200b Metode Gauss-Jordan merupakan suatu variasi dari Eliminasi Gauss dan dalam bahasa analitik biasanya lebih dikenal dengan nama reduksi baris. Perbedaan utamanya dengan eliminasi Gauss adalah bila sebuah yang tidak diketahui dieliminasikan dengan metode Gauss-Jordan maka ia deliminasikan dari setiap persamaan lainnya. Ini merupakan bentuk matrik kesatuan,padahal eliminasi Gauss merupakan matrik triangular. Dasar Teori \u00b6 Penambahan Matrik sebelah kiri diubah menjadi matrik diagonal Penyelesaian dari persamaan linier simultan diatas adalah nilai d1,d2,d3,\u2026,dn dan atau x1 = d1,x2 = d2,x3=d3,\u2026.,xn=dn Teknik yang digunakan dalam metode eliminasi Gauss-Jordan ini sama seperti metode eliminasi Gauss yaitu menggunakan OBE (Operasi Baris Elementer). Hanya perhitungan penyelesaian secara langsung diperoleh dari nilai pada kolom terakhir dari setiap baris . Satu cara yang gamblang untuk menghitung inversi ialah dengan menggunakan metode Gauss-Jordan. Untuk melakukan ini,matriks koefisien diperluas dengan sebuah matriks kesatuan. Kemudian metode Gauss Jordan diterapkan agar mengurangi matriks koefisien menjadi sebuah matriks kesatuan. Jika ini telah selesai, ruas kanan matriks yang diperluas akan mengandung inversi Contoh \u00b6 \u2022Selesaikan sistem persamaan : Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Hasil Run: \u00b6 Hasil 1 : Masukkan ukuran Matrix : 3 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Hasil : 6 Masukkan Hasil : 2 Masukkan Hasil : 3 Matrix A : [[ 1. 1. 1. ] [ 0. - 2. 1. ] [ 0. 0. - 3.5 ]] Nilai X 3 = 2.0 Nilai X 2 = 3.0 Nilai X 1 = 1.0 Metode Jacobi \u00b6 \u200b Metode [Iterasi] Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linear dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan [persamaan linear] berukuran besar dan proporsi koefisien nolnya besar. Kalau kita mengubah dalam Sistem Persamaan Linear, maka dapat ditulis sebagai berikut: Ax=b Kemudian, diketahui bahwa A =D + (L + U), di mana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Kemudian, persamaan di atas dapat diubah menjadi: Dx + (L + U)x=b Kemudian, \u00d7 = D \u0304 \u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] Jika ditulis dalam aturan iteratif, maka metode Jacobi dapat ditulis sebagai: \u00d7\u207d\u1d4f\u207a\u00b9\u207e = D \u0304\u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] di mana k merupakan banyaknya iterasi. Jika \u00d7\u207d\u1d4f\u207e menyatakan hampiran ke-k penyelesaian SPL, maka \u00d7\u207d\u2070\u207e adalah hampiran awal. Algoritme Metode Jacobi \u00b6 INPUT : n , A, b, dan hampiran awal Y =(y1 y2 y3\u2026yn)T , batas toleransi T, dan maksimum iterasi N OUTPUT : X =(x1 x2 x3\u2026xn)T, vektor galat hampiran g , dan H yang merupakan matriks dengan baris vektor-vektor hampiran selama iterasi. Set penghitung iterasi k=1 WHILE k < = N DO FOR i = 1,2,3,\u2026, n , Hitung SET X = ( x*1*x*2*x*3\u2026*x**n ) T IF ||X_Y||<T THEN STOP Tambah penghitung iterasi, k = k + 1 FOR i = 1,2,3,\u2026, n , Set yi=xi SET Y=(y1 y2 y3\u2026yn)T Tulis pesan \u201cMetode gagal setelah N iterasi\u201d STOP Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Hasil Run \u00b6 contoh 1 : Masukkan ukuran Matrix : 3 Masukkan Nilai : 2 Masukkan Nilai : 4 Masukkan Nilai : 3 Masukkan Nilai : 5 Masukkan Nilai : 7 Masukkan Nilai : 3 Masukkan Nilai : 5 Masukkan Nilai : 6 Masukkan Nilai : 3 Masukkan Hasil : 20 Masukkan Hasil : 18 Masukkan Hasil : 30 A : array ([[ 2. , 4. , 3. ], [ 5. , 7. , 3. ], [ 5. , 6. , 3. ]]) b : array ([ 20. , 18. , 30. ]) x : array ([ 2.06506309e+10 , 9.61264713e+09 , 2.15123264e+10 ]) Cotoh 2 : Masukkan ukuran Matrix : 2 Masukkan Nilai : 3 Masukkan Nilai : 6 Masukkan Nilai : 3 Masukkan Nilai : 8 Masukkan Hasil : 9 Masukkan Hasil : 16 A : array ([[ 3. , 6. ], [ 3. , 8. ]]) b : array ([ 9. , 16. ]) x : array ([ - 3.77826554 , 3.45248547 ]) Gauss Seidel \u00b6 \u200b Eliminasi Gauss seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai nilai yang berubah. Bilai diketahui peramaan linier simultan: Konsep Metode Gauss Seidel \u00b6 Hitung nilai xi untuk (i = 1 s/d n) \u00b6 proses iterasi dihentikan apabila bila selisih nilai xi (i = 1 s/d n ) dengan nilai xi pada iterasi sebelumnya kurang dari nilai toleransi error yang ditentukan Algoritma metode Gauss Seidel \u00b6 Masukkan matrik A , dan vektor B beserta ukuranya n. tentukan batas maksimum iterasi max_iter tentukkan toleransi error. tentukan nilai awal dari xi, untuk i =1 s/d n simpan xi dalam si, untuk i=1 s/d n untuk i=1 s/d n hitung iterasi <- iterasi +1 bila iterasi lebih dari max_iter atau tidak terdapat ei<\u03f5 untuk i=1 s/d n maka proses dihentikan dari penyelesaianya adalah xi untuk i=1 s/d n. Bila tidak maka ulangi langkah (5). contoh \u00b6 \u00b6 Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) #print each time the updated solution print ( x ) Masukkan Panjang Matrix: 2 Masukkan a1,1: 2 Masukkan a1,2: 4 Masukkan Hasil: 3 Masukkan a2,1: 5 Masukkan a2,2: 3 Masukkan Hasil: 8 [0, 0, 0] [1.5, 0.16666666666666666, 0] [1.1666666666666667, 0.722222222222222, 0] [0.055555555555556024, 2.574074074074073, 0] [-3.648148148148146, 8.74691358024691, 0] [-15.993827160493819, 29.3230452674897, 0] [-57.1460905349794, 97.91015089163233, 0] [-194.32030178326465, 326.53383630544107, 0] [-651.5676726108821, 1088.6127876848036, 0] [-2175.725575369607, 3628.8759589493457, 0] [-7256.251917898691, 12096.419863164485, 0] [-24191.33972632897, 40321.566210548284, 0] [-80641.63242109657, 134405.38736849427, 0] [-268809.27473698853, 448018.1245616476, 0] [-896034.7491232952, 1493393.915205492, 0] [-2986786.330410984, 4977979.884018307, 0] [-9955958.268036613, 16593266.446727687, 0] [-33186531.393455375, 55310888.322425626, 0] [-110621775.14485125, 184369627.90808544, 0] [-368739254.3161709, 614565426.5269514, 0] [-1229130851.5539029, 2048551421.9231713, 0] [-4097102842.3463426, 6828504739.910571, 0] [-13657009478.321142, 22761682466.535236, 0] [-45523364931.57047, 75872274888.61745, 0] [-151744549775.7349, 252907582962.22482, 0] [-505815165922.94965, 843025276540.916, 0] [-1686050553080.332, 2810084255136.553, 0] [-5620168510271.606, 9366947517122.01, 0] [-18733895034242.52, 31223158390406.863, 0] [-62446316780812.23, 104077194634689.7, 0] [-208154389269377.9, 346923982115632.5, 0] [-693847964231263.5, 1156413273718775.2, 0] [-2312826547437549.0, 3854710912395917.5, 0] [-7709421824791834.0, 1.2849036374653058e+16, 0] [-2.5698072749306116e+16, 4.283012124884353e+16, 0] [-8.566024249768706e+16, 1.4276707082947842e+17, 0] [-2.8553414165895683e+17, 4.7589023609826144e+17, 0] [-9.517804721965229e+17, 1.5863007869942047e+18, 0] [-3.1726015739884093e+18, 5.287669289980682e+18, 0] [-1.0575338579961364e+19, 1.7625564299935607e+19, 0] [-3.5251128599871214e+19, 5.875188099978536e+19, 0] [-1.1750376199957071e+20, 1.9583960333261786e+20, 0] [-3.916792066652357e+20, 6.527986777753928e+20, 0] [-1.3055973555507857e+21, 2.1759955925846427e+21, 0] [-4.3519911851692854e+21, 7.253318641948809e+21, 0] [-1.4506637283897618e+22, 2.417772880649603e+22, 0] [-4.835545761299206e+22, 8.059242935498677e+22, 0] [-1.6118485870997353e+23, 2.6864143118328925e+23, 0] [-5.372828623665785e+23, 8.954714372776308e+23, 0] [-1.7909428745552617e+24, 2.984904790925436e+24, 0] [-5.969809581850872e+24, 9.94968263641812e+24, 0] [-1.989936527283624e+25, 3.3165608788060404e+25, 0] [-6.633121757612081e+25, 1.1055202929353469e+26, 0] [-2.2110405858706938e+26, 3.685067643117823e+26, 0] [-7.370135286235646e+26, 1.2283558810392744e+27, 0] [-2.4567117620785488e+27, 4.094519603464248e+27, 0] [-8.189039206928496e+27, 1.364839867821416e+28, 0] [-2.729679735642832e+28, 4.549466226071387e+28, 0] [-9.098932452142774e+28, 1.5164887420237957e+29, 0] [-3.0329774840475915e+29, 5.054962473412652e+29, 0] [-1.0109924946825304e+30, 1.6849874911375506e+30, 0] [-3.3699749822751013e+30, 5.616624970458502e+30, 0] [-1.1233249940917004e+31, 1.8722083234861674e+31, 0] [-3.7444166469723348e+31, 6.240694411620558e+31, 0] [-1.2481388823241117e+32, 2.0802314705401862e+32, 0] [-4.1604629410803725e+32, 6.934104901800621e+32, 0] [-1.3868209803601242e+33, 2.311368300600207e+33, 0] [-4.622736601200414e+33, 7.704561002000691e+33, 0] [-1.5409122004001381e+34, 2.568187000666897e+34, 0] [-5.136374001333794e+34, 8.560623335556324e+34, 0] [-1.712124667111265e+35, 2.853541111852108e+35, 0] [-5.707082223704216e+35, 9.511803706173693e+35, 0] [-1.9023607412347386e+36, 3.170601235391231e+36, 0] [-6.341202470782462e+36, 1.0568670784637437e+37, 0] [-2.1137341569274874e+37, 3.5228902615458124e+37, 0] [-7.045780523091625e+37, 1.1742967538486043e+38, 0] [-2.3485935076972086e+38, 3.914322512828681e+38, 0] [-7.828645025657362e+38, 1.3047741709428937e+39, 0] [-2.6095483418857873e+39, 4.349247236476312e+39, 0] [-8.698494472952624e+39, 1.4497490788254373e+40, 0] [-2.8994981576508745e+40, 4.832496929418125e+40, 0] [-9.66499385883625e+40, 1.6108323098060416e+41, 0] [-3.221664619612083e+41, 5.369441032686805e+41, 0] [-1.073888206537361e+42, 1.789813677562268e+42, 0] [-3.579627355124536e+42, 5.966045591874227e+42, 0] [-1.1932091183748453e+43, 1.9886818639580756e+43, 0] [-3.977363727916151e+43, 6.628939546526918e+43, 0] [-1.3257879093053837e+44, 2.209646515508973e+44, 0] [-4.419293031017946e+44, 7.365488385029909e+44, 0] [-1.4730976770059818e+45, 2.4551627950099695e+45, 0] [-4.910325590019939e+45, 8.183875983366565e+45, 0] [-1.636775196673313e+46, 2.727958661122189e+46, 0] [-5.455917322244377e+46, 9.093195537073962e+46, 0] [-1.8186391074147924e+47, 3.0310651790246545e+47, 0] [-6.062130358049309e+47, 1.0103550596748849e+48, 0] [-2.0207101193497698e+48, 3.3678501989162833e+48, 0] [-6.735700397832567e+48, 1.1226167329720944e+49, 0] [-2.245233465944189e+49, 3.742055776573648e+49, 0] [-7.484111553147296e+49, 1.2473519255245493e+50, 0] [-2.4947038510490986e+50, 4.1578397517484975e+50, 0] [-8.315679503496995e+50, 1.385946583916166e+51, 0] >>>","title":"Tugas 3"},{"location":"Metode%20Eliminasi%20Gauss/#metode-eliminasi-gauss-jordan","text":"\u200b Metode Gauss-Jordan merupakan suatu variasi dari Eliminasi Gauss dan dalam bahasa analitik biasanya lebih dikenal dengan nama reduksi baris. Perbedaan utamanya dengan eliminasi Gauss adalah bila sebuah yang tidak diketahui dieliminasikan dengan metode Gauss-Jordan maka ia deliminasikan dari setiap persamaan lainnya. Ini merupakan bentuk matrik kesatuan,padahal eliminasi Gauss merupakan matrik triangular.","title":"**Metode Eliminasi Gauss Jordan**"},{"location":"Metode%20Eliminasi%20Gauss/#dasar-teori","text":"Penambahan Matrik sebelah kiri diubah menjadi matrik diagonal Penyelesaian dari persamaan linier simultan diatas adalah nilai d1,d2,d3,\u2026,dn dan atau x1 = d1,x2 = d2,x3=d3,\u2026.,xn=dn Teknik yang digunakan dalam metode eliminasi Gauss-Jordan ini sama seperti metode eliminasi Gauss yaitu menggunakan OBE (Operasi Baris Elementer). Hanya perhitungan penyelesaian secara langsung diperoleh dari nilai pada kolom terakhir dari setiap baris . Satu cara yang gamblang untuk menghitung inversi ialah dengan menggunakan metode Gauss-Jordan. Untuk melakukan ini,matriks koefisien diperluas dengan sebuah matriks kesatuan. Kemudian metode Gauss Jordan diterapkan agar mengurangi matriks koefisien menjadi sebuah matriks kesatuan. Jika ini telah selesai, ruas kanan matriks yang diperluas akan mengandung inversi","title":"Dasar Teori"},{"location":"Metode%20Eliminasi%20Gauss/#contoh","text":"\u2022Selesaikan sistem persamaan :","title":"Contoh"},{"location":"Metode%20Eliminasi%20Gauss/#program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ])","title":"Program"},{"location":"Metode%20Eliminasi%20Gauss/#hasil-run","text":"Hasil 1 : Masukkan ukuran Matrix : 3 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Nilai : 2 Masukkan Nilai : 2 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Hasil : 6 Masukkan Hasil : 2 Masukkan Hasil : 3 Matrix A : [[ 1. 1. 1. ] [ 0. - 2. 1. ] [ 0. 0. - 3.5 ]] Nilai X 3 = 2.0 Nilai X 2 = 3.0 Nilai X 1 = 1.0","title":"Hasil Run:"},{"location":"Metode%20Eliminasi%20Gauss/#metode-jacobi","text":"\u200b Metode [Iterasi] Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linear dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan [persamaan linear] berukuran besar dan proporsi koefisien nolnya besar. Kalau kita mengubah dalam Sistem Persamaan Linear, maka dapat ditulis sebagai berikut: Ax=b Kemudian, diketahui bahwa A =D + (L + U), di mana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Kemudian, persamaan di atas dapat diubah menjadi: Dx + (L + U)x=b Kemudian, \u00d7 = D \u0304 \u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] Jika ditulis dalam aturan iteratif, maka metode Jacobi dapat ditulis sebagai: \u00d7\u207d\u1d4f\u207a\u00b9\u207e = D \u0304\u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] di mana k merupakan banyaknya iterasi. Jika \u00d7\u207d\u1d4f\u207e menyatakan hampiran ke-k penyelesaian SPL, maka \u00d7\u207d\u2070\u207e adalah hampiran awal.","title":"Metode Jacobi"},{"location":"Metode%20Eliminasi%20Gauss/#algoritme-metode-jacobi","text":"INPUT : n , A, b, dan hampiran awal Y =(y1 y2 y3\u2026yn)T , batas toleransi T, dan maksimum iterasi N OUTPUT : X =(x1 x2 x3\u2026xn)T, vektor galat hampiran g , dan H yang merupakan matriks dengan baris vektor-vektor hampiran selama iterasi. Set penghitung iterasi k=1 WHILE k < = N DO FOR i = 1,2,3,\u2026, n , Hitung SET X = ( x*1*x*2*x*3\u2026*x**n ) T IF ||X_Y||<T THEN STOP Tambah penghitung iterasi, k = k + 1 FOR i = 1,2,3,\u2026, n , Set yi=xi SET Y=(y1 y2 y3\u2026yn)T Tulis pesan \u201cMetode gagal setelah N iterasi\u201d STOP","title":"Algoritme Metode Jacobi"},{"location":"Metode%20Eliminasi%20Gauss/#program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol )","title":"Program"},{"location":"Metode%20Eliminasi%20Gauss/#hasil-run_1","text":"contoh 1 : Masukkan ukuran Matrix : 3 Masukkan Nilai : 2 Masukkan Nilai : 4 Masukkan Nilai : 3 Masukkan Nilai : 5 Masukkan Nilai : 7 Masukkan Nilai : 3 Masukkan Nilai : 5 Masukkan Nilai : 6 Masukkan Nilai : 3 Masukkan Hasil : 20 Masukkan Hasil : 18 Masukkan Hasil : 30 A : array ([[ 2. , 4. , 3. ], [ 5. , 7. , 3. ], [ 5. , 6. , 3. ]]) b : array ([ 20. , 18. , 30. ]) x : array ([ 2.06506309e+10 , 9.61264713e+09 , 2.15123264e+10 ]) Cotoh 2 : Masukkan ukuran Matrix : 2 Masukkan Nilai : 3 Masukkan Nilai : 6 Masukkan Nilai : 3 Masukkan Nilai : 8 Masukkan Hasil : 9 Masukkan Hasil : 16 A : array ([[ 3. , 6. ], [ 3. , 8. ]]) b : array ([ 9. , 16. ]) x : array ([ - 3.77826554 , 3.45248547 ])","title":"Hasil Run"},{"location":"Metode%20Eliminasi%20Gauss/#gauss-seidel","text":"\u200b Eliminasi Gauss seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai nilai yang berubah. Bilai diketahui peramaan linier simultan:","title":"Gauss Seidel"},{"location":"Metode%20Eliminasi%20Gauss/#konsep-metode-gauss-seidel","text":"Hitung nilai xi untuk (i = 1 s/d n)","title":"Konsep Metode Gauss Seidel"},{"location":"Metode%20Eliminasi%20Gauss/#_1","text":"proses iterasi dihentikan apabila bila selisih nilai xi (i = 1 s/d n ) dengan nilai xi pada iterasi sebelumnya kurang dari nilai toleransi error yang ditentukan","title":""},{"location":"Metode%20Eliminasi%20Gauss/#algoritma-metode-gauss-seidel","text":"Masukkan matrik A , dan vektor B beserta ukuranya n. tentukan batas maksimum iterasi max_iter tentukkan toleransi error. tentukan nilai awal dari xi, untuk i =1 s/d n simpan xi dalam si, untuk i=1 s/d n untuk i=1 s/d n hitung iterasi <- iterasi +1 bila iterasi lebih dari max_iter atau tidak terdapat ei<\u03f5 untuk i=1 s/d n maka proses dihentikan dari penyelesaianya adalah xi untuk i=1 s/d n. Bila tidak maka ulangi langkah (5).","title":"Algoritma metode Gauss Seidel"},{"location":"Metode%20Eliminasi%20Gauss/#contoh_1","text":"","title":"contoh"},{"location":"Metode%20Eliminasi%20Gauss/#_2","text":"","title":""},{"location":"Metode%20Eliminasi%20Gauss/#program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) #print each time the updated solution print ( x ) Masukkan Panjang Matrix: 2 Masukkan a1,1: 2 Masukkan a1,2: 4 Masukkan Hasil: 3 Masukkan a2,1: 5 Masukkan a2,2: 3 Masukkan Hasil: 8 [0, 0, 0] [1.5, 0.16666666666666666, 0] [1.1666666666666667, 0.722222222222222, 0] [0.055555555555556024, 2.574074074074073, 0] [-3.648148148148146, 8.74691358024691, 0] [-15.993827160493819, 29.3230452674897, 0] [-57.1460905349794, 97.91015089163233, 0] [-194.32030178326465, 326.53383630544107, 0] [-651.5676726108821, 1088.6127876848036, 0] [-2175.725575369607, 3628.8759589493457, 0] [-7256.251917898691, 12096.419863164485, 0] [-24191.33972632897, 40321.566210548284, 0] [-80641.63242109657, 134405.38736849427, 0] [-268809.27473698853, 448018.1245616476, 0] [-896034.7491232952, 1493393.915205492, 0] [-2986786.330410984, 4977979.884018307, 0] [-9955958.268036613, 16593266.446727687, 0] [-33186531.393455375, 55310888.322425626, 0] [-110621775.14485125, 184369627.90808544, 0] [-368739254.3161709, 614565426.5269514, 0] [-1229130851.5539029, 2048551421.9231713, 0] [-4097102842.3463426, 6828504739.910571, 0] [-13657009478.321142, 22761682466.535236, 0] [-45523364931.57047, 75872274888.61745, 0] [-151744549775.7349, 252907582962.22482, 0] [-505815165922.94965, 843025276540.916, 0] [-1686050553080.332, 2810084255136.553, 0] [-5620168510271.606, 9366947517122.01, 0] [-18733895034242.52, 31223158390406.863, 0] [-62446316780812.23, 104077194634689.7, 0] [-208154389269377.9, 346923982115632.5, 0] [-693847964231263.5, 1156413273718775.2, 0] [-2312826547437549.0, 3854710912395917.5, 0] [-7709421824791834.0, 1.2849036374653058e+16, 0] [-2.5698072749306116e+16, 4.283012124884353e+16, 0] [-8.566024249768706e+16, 1.4276707082947842e+17, 0] [-2.8553414165895683e+17, 4.7589023609826144e+17, 0] [-9.517804721965229e+17, 1.5863007869942047e+18, 0] [-3.1726015739884093e+18, 5.287669289980682e+18, 0] [-1.0575338579961364e+19, 1.7625564299935607e+19, 0] [-3.5251128599871214e+19, 5.875188099978536e+19, 0] [-1.1750376199957071e+20, 1.9583960333261786e+20, 0] [-3.916792066652357e+20, 6.527986777753928e+20, 0] [-1.3055973555507857e+21, 2.1759955925846427e+21, 0] [-4.3519911851692854e+21, 7.253318641948809e+21, 0] [-1.4506637283897618e+22, 2.417772880649603e+22, 0] [-4.835545761299206e+22, 8.059242935498677e+22, 0] [-1.6118485870997353e+23, 2.6864143118328925e+23, 0] [-5.372828623665785e+23, 8.954714372776308e+23, 0] [-1.7909428745552617e+24, 2.984904790925436e+24, 0] [-5.969809581850872e+24, 9.94968263641812e+24, 0] [-1.989936527283624e+25, 3.3165608788060404e+25, 0] [-6.633121757612081e+25, 1.1055202929353469e+26, 0] [-2.2110405858706938e+26, 3.685067643117823e+26, 0] [-7.370135286235646e+26, 1.2283558810392744e+27, 0] [-2.4567117620785488e+27, 4.094519603464248e+27, 0] [-8.189039206928496e+27, 1.364839867821416e+28, 0] [-2.729679735642832e+28, 4.549466226071387e+28, 0] [-9.098932452142774e+28, 1.5164887420237957e+29, 0] [-3.0329774840475915e+29, 5.054962473412652e+29, 0] [-1.0109924946825304e+30, 1.6849874911375506e+30, 0] [-3.3699749822751013e+30, 5.616624970458502e+30, 0] [-1.1233249940917004e+31, 1.8722083234861674e+31, 0] [-3.7444166469723348e+31, 6.240694411620558e+31, 0] [-1.2481388823241117e+32, 2.0802314705401862e+32, 0] [-4.1604629410803725e+32, 6.934104901800621e+32, 0] [-1.3868209803601242e+33, 2.311368300600207e+33, 0] [-4.622736601200414e+33, 7.704561002000691e+33, 0] [-1.5409122004001381e+34, 2.568187000666897e+34, 0] [-5.136374001333794e+34, 8.560623335556324e+34, 0] [-1.712124667111265e+35, 2.853541111852108e+35, 0] [-5.707082223704216e+35, 9.511803706173693e+35, 0] [-1.9023607412347386e+36, 3.170601235391231e+36, 0] [-6.341202470782462e+36, 1.0568670784637437e+37, 0] [-2.1137341569274874e+37, 3.5228902615458124e+37, 0] [-7.045780523091625e+37, 1.1742967538486043e+38, 0] [-2.3485935076972086e+38, 3.914322512828681e+38, 0] [-7.828645025657362e+38, 1.3047741709428937e+39, 0] [-2.6095483418857873e+39, 4.349247236476312e+39, 0] [-8.698494472952624e+39, 1.4497490788254373e+40, 0] [-2.8994981576508745e+40, 4.832496929418125e+40, 0] [-9.66499385883625e+40, 1.6108323098060416e+41, 0] [-3.221664619612083e+41, 5.369441032686805e+41, 0] [-1.073888206537361e+42, 1.789813677562268e+42, 0] [-3.579627355124536e+42, 5.966045591874227e+42, 0] [-1.1932091183748453e+43, 1.9886818639580756e+43, 0] [-3.977363727916151e+43, 6.628939546526918e+43, 0] [-1.3257879093053837e+44, 2.209646515508973e+44, 0] [-4.419293031017946e+44, 7.365488385029909e+44, 0] [-1.4730976770059818e+45, 2.4551627950099695e+45, 0] [-4.910325590019939e+45, 8.183875983366565e+45, 0] [-1.636775196673313e+46, 2.727958661122189e+46, 0] [-5.455917322244377e+46, 9.093195537073962e+46, 0] [-1.8186391074147924e+47, 3.0310651790246545e+47, 0] [-6.062130358049309e+47, 1.0103550596748849e+48, 0] [-2.0207101193497698e+48, 3.3678501989162833e+48, 0] [-6.735700397832567e+48, 1.1226167329720944e+49, 0] [-2.245233465944189e+49, 3.742055776573648e+49, 0] [-7.484111553147296e+49, 1.2473519255245493e+50, 0] [-2.4947038510490986e+50, 4.1578397517484975e+50, 0] [-8.315679503496995e+50, 1.385946583916166e+51, 0] >>>","title":"Program"},{"location":"Metode%20Rekursif%20Trapezoid/","text":"Metode Rekursif Trapezoid \u00b6 Metode rekursif trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann.Selanjutnya,menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus, Dengan F(x) adalah antiderivatif f(x) (yakni F\u2019(x)=f(x) ). \u200b Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran *f(x)*tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. \u200b Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif. Berikut akan dijelaskan penghitungan integral tentu menggunakan Aturan Trapesium Rekursif. Aturan Metode Rekursif Trapezoid \u00b6 Misalkan f adalah suatu fungsi yang terdefinisi pada [a,b] . Misalkan suatu partisi sedemikian sehingga dengan xk = xo +kh dengan h= (b - a)/n untuk k=0,1,2,3,...n . Perhatikan aturan trapesium untuk fungsi f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval), Jika lebar setiap subinterval diperkecil separonya, maka didapat Pada (1) berlaku f_{k}=f(x_{0}+kh) sedangkan pada (2) berlaku f_{k}=f(x_{0}+kh/2 sehingga f_{2k} pada (2) sama dengan f_{k} pada (1). Rumus (3) disebut rumus trapesium rekursif. Rumus ini memungkinkan penggunaan aturan trapesium majemuk secara efisien, tanpa harus menghitung ulang nilai-nilai fungsi di beberapa absis yang sudah dihitung sebelumnya. Untuk h=(b-a) dan n=1,2,4,8,16.......} atau $$ n=2 {0},2 {1},2 {2},2 {3},2 {4},......,2 {k}...... $$ Kita akan mendapatkan barisan aturan trapesium $$ T_{0},T_{1},T_{2},T_{3},.....T_{k},... $$ dengan $$ T_{0}=T_{1}(f,h)={\\frac {h}{2}}(f(a)+f(b)) $$ dan $$ T_{k}=T_{2^{k}}(f,{\\frac {h}{2^{k}}}), k=1,2,3,... $$ yang memenuhi hubungan dengan Langkang-langkah Metode Rekursif Trapezoid \u00b6 Dalam menghitung hampiran $$ \\int _{a}^{b}f(x)\\,dx $$ dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut; Program \u00b6 #mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Masukkan batas bawah = \" )) b = float ( input ( \"Masukkan batas atas = \" )) c = int ( input ( \"Masukkan nilai n =\" )) error = [] print ( \" \" ) print ( \"<<-------------Hasil penghitungan----------------->>\" ) print ( \"banyak iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Nilai Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil ) Hasil Run \u00b6 RESTART: C:/Users/Nuron/Desktop/Semester_4/Komputasi Numerik/Tugas/Tugas_4/trapezoid.py Rumus digunakan adalah = f(x) = 1/(1+x) Masukkan batas bawah = 2 Masukkan batas atas = 6 Masukkan nilai n =20 <<-------------Hasil penghitungan----------------->> banyak iterasi n Nilai Trapezoid 1 1 0.9523809523809523 2 2 0.8761904761904762 3 4 0.8547619047619047 4 8 0.8491813741813743 5 16 0.8477698845652135 6 32 0.847415938934486 7 64 0.8473273845698198 8 128 0.8473052417171961 9 256 0.8472997057374764 10 512 0.8472983217258828 11 1024 0.8472979757219435 12 2048 0.8472978892208934 13 4096 0.8472978675956261 14 8192 0.8472978621893126 15 16384 0.847297860837734 16 32768 0.8472978604998384 17 65536 0.8472978604153515 18 131072 0.8472978603942459 19 262144 0.8472978603889699 20 524288 0.8472978603876457 0.8472978603889699 0.8472978603876457 estimasi error = 1.3242740237728867e-12 Terima kasih semoga bermanfaat","title":"Tugas 4"},{"location":"Metode%20Rekursif%20Trapezoid/#metode-rekursif-trapezoid","text":"Metode rekursif trapezoid merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann.Selanjutnya,menurut Teorema Dasar Kalkulus integral tersebut dapat dihitung dengan rumus, Dengan F(x) adalah antiderivatif f(x) (yakni F\u2019(x)=f(x) ). \u200b Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran *f(x)*tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. \u200b Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif. Berikut akan dijelaskan penghitungan integral tentu menggunakan Aturan Trapesium Rekursif.","title":"Metode Rekursif Trapezoid"},{"location":"Metode%20Rekursif%20Trapezoid/#aturan-metode-rekursif-trapezoid","text":"Misalkan f adalah suatu fungsi yang terdefinisi pada [a,b] . Misalkan suatu partisi sedemikian sehingga dengan xk = xo +kh dengan h= (b - a)/n untuk k=0,1,2,3,...n . Perhatikan aturan trapesium untuk fungsi f terhadap partisi di atas (untuk keperluan pembahasan pada bagian ini, kita gunakan notasi kuadratur dengan menyertakan cacah dan lebar subinterval), Jika lebar setiap subinterval diperkecil separonya, maka didapat Pada (1) berlaku f_{k}=f(x_{0}+kh) sedangkan pada (2) berlaku f_{k}=f(x_{0}+kh/2 sehingga f_{2k} pada (2) sama dengan f_{k} pada (1). Rumus (3) disebut rumus trapesium rekursif. Rumus ini memungkinkan penggunaan aturan trapesium majemuk secara efisien, tanpa harus menghitung ulang nilai-nilai fungsi di beberapa absis yang sudah dihitung sebelumnya. Untuk h=(b-a) dan n=1,2,4,8,16.......} atau $$ n=2 {0},2 {1},2 {2},2 {3},2 {4},......,2 {k}...... $$ Kita akan mendapatkan barisan aturan trapesium $$ T_{0},T_{1},T_{2},T_{3},.....T_{k},... $$ dengan $$ T_{0}=T_{1}(f,h)={\\frac {h}{2}}(f(a)+f(b)) $$ dan $$ T_{k}=T_{2^{k}}(f,{\\frac {h}{2^{k}}}), k=1,2,3,... $$ yang memenuhi hubungan dengan","title":"Aturan Metode Rekursif Trapezoid"},{"location":"Metode%20Rekursif%20Trapezoid/#langkang-langkah-metode-rekursif-trapezoid","text":"Dalam menghitung hampiran $$ \\int _{a}^{b}f(x)\\,dx $$ dengan aturan trapesium rekursif, kita lakukan langkah-langkah sebagai berikut;","title":"Langkang-langkah Metode Rekursif Trapezoid"},{"location":"Metode%20Rekursif%20Trapezoid/#program","text":"#mendefinisikan fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \" \" ) print ( \"Rumus digunakan adalah = f(x) = 1/(1+x)\" ) print ( \" \" ) a = float ( input ( \"Masukkan batas bawah = \" )) b = float ( input ( \"Masukkan batas atas = \" )) c = int ( input ( \"Masukkan nilai n =\" )) error = [] print ( \" \" ) print ( \"<<-------------Hasil penghitungan----------------->>\" ) print ( \"banyak iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Nilai Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trapezoid = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 error . append ( trapezoid ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trapezoid ) print ( error [ iterasi - 1 ]) print ( error [ iterasi ]) hasil = ( error [ iterasi - 1 ] - error [ iterasi ]) print ( \"estimasi error =\" , hasil )","title":"Program"},{"location":"Metode%20Rekursif%20Trapezoid/#hasil-run","text":"RESTART: C:/Users/Nuron/Desktop/Semester_4/Komputasi Numerik/Tugas/Tugas_4/trapezoid.py Rumus digunakan adalah = f(x) = 1/(1+x) Masukkan batas bawah = 2 Masukkan batas atas = 6 Masukkan nilai n =20 <<-------------Hasil penghitungan----------------->> banyak iterasi n Nilai Trapezoid 1 1 0.9523809523809523 2 2 0.8761904761904762 3 4 0.8547619047619047 4 8 0.8491813741813743 5 16 0.8477698845652135 6 32 0.847415938934486 7 64 0.8473273845698198 8 128 0.8473052417171961 9 256 0.8472997057374764 10 512 0.8472983217258828 11 1024 0.8472979757219435 12 2048 0.8472978892208934 13 4096 0.8472978675956261 14 8192 0.8472978621893126 15 16384 0.847297860837734 16 32768 0.8472978604998384 17 65536 0.8472978604153515 18 131072 0.8472978603942459 19 262144 0.8472978603889699 20 524288 0.8472978603876457 0.8472978603889699 0.8472978603876457 estimasi error = 1.3242740237728867e-12 Terima kasih semoga bermanfaat","title":"Hasil Run"}]}